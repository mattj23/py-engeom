{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Engeom (Python Bindings)","text":"<p>This site has the documentation for the Python bindings of the <code>engeom</code> library. </p> <p>The <code>engeom</code> library is a Rust library for 2D and 3D engineering geometry, with a specific focus on metrology applications.  The Python bindings provide a way to use some of the library's functionality in Python, with a reasonably similar interface to the Rust library.</p> <p>The bindings are built using <code>pyo3</code> and <code>maturin</code> and <code>engeom</code> is compiled as a self-contained extension library, so the python module is the only thing which needs to be installed on an interpreter for everything to work.  It is available for Python versions <code>&gt;=3.8</code>, for Windows/Linux/macOS, and on most common 64-bit architectures.</p>"},{"location":"#quick-overview","title":"Quick Overview","text":"<p>The <code>engeom</code> Python library has a few general feature sets:</p> <ul> <li>2D and 3D geometric primitives (points, vectors, planes, circles/arcs, line segments, transformation matrices, etc) which can be used to represent and perform basic geometric operations through a simple and consistent interface.</li> <li>More complicated entities like 3D triangle meshes, 2D and 3D polylines, and 3D point clouds, with common operations like intersections, projections, distance queries, transformations, etc.</li> <li>Some basic fitting and alignment algorithms for 2D and 3D data</li> <li>Helper functions for plotting and visualization to assist in use of the <code>matplotlib</code> and <code>pyvista</code> libraries.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>The Python bindings can be installed using <code>pip</code>:</p> <pre><code>pip install engeom\n</code></pre>"},{"location":"bounding_volumes/","title":"Bounding Volumes","text":"<p>There are currently two types of bounding volumes available in the <code>engeom</code> library. Both are axis-aligned bounding boxes (AABBs), but one is for 2D (<code>Aabb2</code>) and the other is for 3D (<code>Aabb3</code>).</p> <p>These bounding volumes are primarily used within the Rust language library as an internal mechanism to support data structures which accelerate distance queries and intersection checks. However, they also have a number of useful features and so are exposed to the Python API.</p>"},{"location":"bounding_volumes/#creating-bounding-volumes","title":"Creating Bounding Volumes","text":"<p>Most commonly, bounding volumes are created internally by the library for geometries that are part of acceleration structures or have clear spatial bounds, and accessed by retrieving them from those entities. However, through the Python API, they can also be created directly.</p> <pre><code>from engeom.geom2 import Aabb2\nfrom engeom.geom3 import Aabb3\n\n# Create a 2D AABB. The arguments are x_min, y_min, x_max, y_max.\nbox2 = Aabb2(-1, -2, 3, 4)\n\n# Create a 3D AABB. The arguments are x_min, y_min, z_min, x_max, y_max, z_max.\nbox3 = Aabb3(-1, -2, -3, 3, 4, 5)\n</code></pre> <p>Two other convenient methods for creating bounding volumes are <code>from_points</code> and <code>at_point</code>.</p> <p>The <code>from_points</code> function creates a bounding volume that contains all the points in the input list. Pass it a list of points as a numpy array, and it will determine the bounds.</p> <pre><code>import numpy\nfrom engeom.geom2 import Aabb2\nfrom engeom.geom3 import Aabb3\n\npoints = numpy.array([[0, 0, 0],\n                      [1, 1, 1],\n                      [2, 2, 2],\n                      [3, 3, 3]]).astype(numpy.float64)\n\n# Create boxes that contain all the points\nbox2 = Aabb2.from_points(points[:, :2])\nbox3 = Aabb3.from_points(points)\n</code></pre> <p>The <code>at_point</code> function creates a bounding volume centered at the specified point with the specified dimensions. The arguments are the center point and the dimensions of the box. The 2D version takes 4 arguments (x, y, width, height), and the 3D version takes 6 arguments (x, y, z, width, height, depth).</p> <pre><code>from engeom.geom2 import Aabb2\nfrom engeom.geom3 import Aabb3\n\n# Create a 2D AABB centered at the point (1, 2) that is 3 units wide (x) \n# and 4 units tall (y).\nbox2 = Aabb2.at_point(1, 2, 3, 4)\n\n# Create a 3D AABB centered at the point (1, 2, 3) that is 4 units wide (x),\n# 5 units tall (y), and 6 units deep (z).\nbox3 = Aabb3.at_point(1, 2, 3, 4, 5, 6)\n</code></pre>"},{"location":"bounding_volumes/#bounding-volume-properties","title":"Bounding Volume Properties","text":"<p>There are four properties of bounding volumes, both 2D and 3D, that can be accessed and yield point and vector values related to the geometry of the volume.</p> Property Type Description <code>.center</code> <code>Point2</code>/<code>Point3</code> The center point of the bounding volume <code>.min</code> <code>Point2</code>/<code>Point3</code> The minimum corner point of the bounding volume <code>.max</code> <code>Point2</code>/<code>Point3</code> The maximum corner point of the bounding volume <code>.extent</code> <code>Vector2</code>/<code>Vector3</code> The extents of the bounding volume (equivalent to <code>.max - .min</code>) <pre><code>from engeom.geom3 import Aabb3\n\nbox = Aabb3(-1, -2, -3, 1, 2, 3)\n\n# Get the center point of the box\nprint(box.center)  # Point3(0, 0, 0)\nprint(box.min)     # Point3(-1, -2, -3)\nprint(box.max)     # Point3(1, 2, 3)\nprint(box.extent)  # Vector3(2, 4, 6)\n</code></pre>"},{"location":"bounding_volumes/#expand-and-shrink","title":"Expand and Shrink","text":"<p>Bounding volumes can be expanded or shrunk by a specified amount, yielding a new bounding volume. The <code>expand</code> and <code>shrink</code> methods take a single argument, which is the amount to expand or shrink the perimeter of the bounding volume.</p> <p>The overall change in the size of the extents will be twice the amount specified. For example, if you expand  a 2D box  by 1 unit, the width and height will each increase by 2 units.</p> <pre><code>from engeom.geom2 import Aabb2\nbox = Aabb2(-1, -2, 1, 2)\n\nprint(box.extent)  # Vector2(2, 4)\n\nexpanded = box.expand(0.5)\nprint(expanded.extent)  # Vector2(3, 5)\n\nshrunk = box.shrink(0.5) \nprint(shrunk.extent)  # Vector2(1, 3)\n</code></pre>"},{"location":"bounding_volumes/#intersection-and-containment","title":"Intersection and Containment","text":"<p>Warning</p> <p>Intersection and containment options are not yet bound to the Python API. This will be added in a future release.</p>"},{"location":"curves/","title":"Curves","text":""},{"location":"curves/#introduction","title":"Introduction","text":"<p>The <code>engeom</code> library has both a 2D and 3D curve type. This type represents a 1-dimensional manifold that consists of a sequence of vertices in \\(\\mathbb{R}^n\\) space that are connected by line-segment edges, sometimes referred to as a polyline.</p> <p>Each curve entity consists of a single contiguous sequence of vertices with a clear start and end point. In the case of the 2D <code>Curve2</code> type, the curve can also be \"closed\", meaning that the end point is connected to the start point to form a closed loop and so operations on the manifold that cross the end point will wrap around to the start point, and vice versa.</p> <p>While the fundamental operations on a curve, such as distance queries and manifold traversal are the same or similar for the 2D and 3D curve types, the 2D curve type has many more features that are made possible by the 2D plane.</p>"},{"location":"curves/#2d-curves","title":"2D Curves","text":"<p>The 2D curve type, <code>Curve2</code>, is a more feature-rich type than the 3D curve type, because the nature of the 2D plane means that a 2D polyline is more conceptually related to a 3D <code>Mesh</code> object than it is to a 3D polyline. A <code>Curve2</code> object can represent a boundary/surface with a clear sense of \"inside\" and \"outside\", and if it forms a closed loop it can model a partitioning of the \\(\\mathbb{R}^2\\) plane into an interior and exterior region.</p> <p>In 2D, a curve has concept of a surface normal direction, which is built from the concept inside/outside defined through the winding order of the vertices. By convention, the segment from vertex \\(i\\) to vertex \\(i+1\\) defines the space to its \"right\" as being outside the curve, and the space to its \"left\" as being inside the curve, resulting in a counter-clockwise winding order defining a positive convex shape.</p>"},{"location":"curves/#creation","title":"Creation","text":"<p>Creation of a <code>Curve2</code> object is done by passing in a list of ordered vertices that define the curve. The vertices will be interpreted in sequential order, so that each vertex will be connected to the next vertex in the list.</p> <p>Adjacent vertices that are within a distance tolerance from each other will be de-duplicated, to prevent the curve from having zero-length segments. Additionally, if the first and last point are within the distance tolerance, the curve will be considered \"closed\" and algorithms which do manifold traversal will wrap between the first and last points.</p> <p>However, because of the importance of winding order on 2D curves, the <code>Curve2</code> type must also be constructed with the vertices in the specific order that matches the intended definition of \"inside\" vs \"outside\" for the curve.</p> <p>While the space occupied by the curve might be exactly the same whether the vertices are constructed in forward or reverse order, the inside vs outside will be opposite.</p> <p>There are three ways that winding order can be specified during construction of a <code>Curve2</code> object:</p> <ol> <li> <p>You can prepare the list of vertices so that they are in the correct order and then pass them into the constructor.    Counter-clockwise order of vertices for positive convex shapes/regions, and clockwise order for negative convex    shapes/regions.</p> </li> <li> <p>If you know that the curve is meant to represent a positive (convex) shape overall, you can set the <code>hull_ccw=True</code>    flag. The constructor will build the convex hull of the vertices you provide and reverse their order if the hull    sequence does not match the input sequence.</p> </li> <li> <p>You may provide the constructor with an array of surface normals that correspond with the vertices. There must be one    normal per vertex in the input list, and it must be pointing in the direction that you intend to be the \"outside\" of    the surface. The constructor will reverse the input order if the majority of normals are not pointing in the same    direction as the winding order would imply.</p> </li> </ol> <p>The input arguments for the constructor are:</p> Argument Type Description <code>vertices</code> <code>numpy.ndarray</code> A 2D array of shape <code>(n, 2)</code> where <code>n</code> is the number of vertices in the curve. The columns are the x and y components of the vertices <code>normals</code> <code>numpy.ndarray</code> OPTIONAL A 2D array of shape <code>(n, 2)</code> where <code>n</code> is the number of vertices in the curve. The columns are the x and y components of the normals at each vertex. Default is <code>None</code>. <code>tol</code> <code>float</code> OPTIONAL A tolerance distance, below which points are considered to be the same and de-duplicated. Default is <code>1e-6</code> <code>force_closed</code> <code>bool</code> OPTIONAL If <code>True</code>, the curve will be guaranteed to be closed. If the first and last point are more than <code>tol</code> distance apart, an additional vertex will be added to the end that overlaps with the beginning. Default is <code>False</code> <code>hull_ccw</code> <code>bool</code> OPTIONAL If <code>True</code>, the vertices will be re-ordered to match the convex hull of the vertices. Default is <code>False</code>. This will be ignored if <code>normals</code> is not <code>None</code> <pre><code>import numpy\nfrom engeom.geom2 import Curve2\n\n# These are the corners of an open unit square\nvertices = numpy.array([[0.0, 0], [1, 0], [1, 1], [0, 1]])\n\n# Create a curve with these vertices and nothing else\nc1 = Curve2(vertices)\nprint(c1)  # &lt;Curve2 n=4, l=3 (open)&gt;\n\n# Force the curve to be closed\nc2 = Curve2(vertices, force_closed=True)\nprint(c2)  # &lt;Curve2 n=5, l=4 (closed)&gt;\n</code></pre>"},{"location":"curves/#stations","title":"Stations","text":"<p>Because a <code>Curve2</code> object is a 1D manifold, every unique position along the curve can be represented by a single scalar value, which is the length from the start of the curve. Each unique position along a 2D curve has several geometric properties which are useful.  These properties are bundled in a <code>CurveStation2</code> object, which is a lightweight data  object that represents a single position on the manifold.</p> <p><code>CurveStation2</code> objects are not created directly, but are retrieved from a <code>Curve2</code> object through one of several different possible queries on the manifold.</p> <p>The <code>CurveStation2</code> object has the following properties:</p> Property Type Description <code>.point</code> <code>Point2</code> The 2D position in space that corresponds with the station on the manifold. <code>.direction</code> <code>Vector2</code> The vector pointing in the direction of positive distance along the curve. Typically this is the vector from the last vertex to the next vertex. <code>.normal</code> <code>Vector2</code> The vector pointing in the direction of the surface normal at the station. This is the <code>direction</code> vector rotated by \\(-90\u00b0\\). <code>.direction_point</code> <code>SurfacePoint2</code> A convenience surface point that combines the <code>point</code> position and <code>direction</code> vector. <code>.surface_point</code> <code>SurfacePoint2</code> A convenience surface point that combines the <code>point</code> position and <code>normal</code> vector. <code>.index</code> <code>int</code> The index of the previous vertex on the curve, at or before the station. <code>.length_along</code> <code>float</code> The distance along the curve from the start to the station. This is the manifold domain."},{"location":"curves/#querying","title":"Querying","text":""},{"location":"isometries/","title":"Isometries (Rigid-body Transformations)","text":"<p>Isometries are a class of transformations that preserve distances between points. They are also known as rigid-body transformations, as they preserve the shape of the object being transformed.</p> <p>In the underlying Rust <code>engeom</code> library, isometries are aliases for a native <code>nalgebra</code> struct. In two dimensions this consists of a 2D translation and a unit complex for rotation, and in three dimensions it consists of a 3D translation and a unit quaternion for rotation.</p> <p>Isometries can be thought of as equivalent to transformation matrices, but with the limitation that certain matrices are not valid isometries because they do not preserve distances. They can be composed together by multiplication according to the rules of matrix multiplication, inverted according to the rules of matrix inversion, and they can be multiplied against points or vectors to transform them.</p>"},{"location":"isometries/#creating-isometries","title":"Creating Isometries","text":"<p>Two-dimensional isometries can be created directly from three scalar values: the x and y components of the translation, and the angle of rotation in radians. Three-dimensional isometries are more complicated, and are easiest to create through composition.</p>"},{"location":"isometries/#two-dimensional-isometries","title":"Two-dimensional Isometries","text":"<pre><code>from math import pi\nfrom engeom.geom2 import Iso2\n\n# Shortcut for the identity transform\ni0 = Iso2.identity()\n\n# Create an isometry that translates by (1, 2) and rotates by pi/4 radians\ni1 = Iso2(1, 2, pi / 4)\n</code></pre>"},{"location":"isometries/#three-dimensional-isometries","title":"Three-dimensional Isometries","text":"<pre><code>import numpy\nfrom math import pi\nfrom engeom.geom3 import Iso3\n\n# Shortcut for the identity transform\ni0 = Iso3.identity()\n\n# Try to create an isometry directly from a 4x4 transformation matrix. Will throw\n# an exception if the matrix is not a valid isometry.\nm = numpy.array([[1, 0, 0, 1],\n                 [0, 1, 0, 2],\n                 [0, 0, 1, 3],\n                 [0, 0, 0, 1]])\ni1 = Iso3(m)\n\n# Create an isometry that only translates by specifying the translation vector\ni2 = Iso3.from_translation(1, 2, 3)\n\n# Create an isometry that rotates by pi/4 radians around the x-axis. See the documentation\n# for `from_rotation` for more information on the arguments.\ni3 = Iso3.from_rotation(pi / 4, 1, 0, 0)\n</code></pre>"},{"location":"isometries/#inverting-isometries","title":"Inverting Isometries","text":"<p>Isometries can, by definition, be inverted. The inverse of an isometry is an isometry that, when applied to the result of the original isometry, returns the original input. An isometry multiplied by its inverse is the identity isometry.</p> <pre><code>from math import pi\nfrom engeom.geom3 import Iso3\n\ni = Iso3.from_rotation(pi / 4, 1, 0, 0)\n\n# Invert the isometry\ni_inv = i.inverse()\n</code></pre>"},{"location":"isometries/#composition","title":"Composition","text":"<p>Isometries can be composed together by multiplying them together. The order of multiplication is important, as isometries do not commute. The result of multiplying two isometries together is a new isometry that is equivalent to apply the right hand isometry first, and then the left hand isometry.</p> <p>The operator for isometry multiplication is the same as the matrix multiplication operator, <code>@</code>.</p> <pre><code>from math import pi\nfrom engeom.geom3 import Iso3\n\ni1 = Iso3.from_rotation(pi / 4, 1, 0, 0)\ni2 = Iso3.from_translation(1, 2, 3)\n\n# Apply the rotation first, then the translation\n\ni3 = i2 @ i1\n</code></pre>"},{"location":"isometries/#transforming-primitives","title":"Transforming Primitives","text":""},{"location":"isometries/#vectors-points-surface-points-etc","title":"Vectors, Points, Surface Points, etc","text":"<p>Isometries can be applied to points, vectors, and other geometric primitives by multiplying them by the isometry using the <code>@</code> operator.</p> <ul> <li>A point transformed by an isometry is a new point that is at a new position in space.</li> <li>A vector transformed by an isometry has been rotated, but its magnitude has not changed.</li> <li>A surface point transformed by an isometry is the result of transforming the point and the normal vector   independently, and then re-constituting them into a new surface point. The position has been moved and the normal   vector rotated but remains of unit magnitude.</li> </ul> <pre><code>from math import pi\nfrom engeom.geom2 import Iso2, Vector2, Point2, SurfacePoint2\n\np = Point2(1, 2)\nv = Vector2(1, 2)\nsp = SurfacePoint2(1, 2, 1, 0)\n\ni = Iso2(1, 2, pi / 4)\n\np2 = i @ p\nv2 = i @ v\nsp2 = i @ sp\n</code></pre>"},{"location":"isometries/#numpy-arrays","title":"Numpy Arrays","text":"<p>For efficient transformation of large numbers of points or vectors, both 2D and 3D isometries can be applied to <code>numpy</code> arrays representing points or vectors according to the rules defined in the previous section.</p> <pre><code>import numpy\nfrom math import pi\nfrom engeom.geom2 import Iso2\n\nvalues = numpy.array([[1, 2],\n                      [3, 4],\n                      [5, 6],\n                      [7, 8]])\n\ni = Iso2(1, 2, pi / 4)\n\n# Apply the isometry to the values as if they were points\nnew_points = i.transform_points(values)\n\n# Apply the isometry to the values as if they were vectors\nnew_vectors = i.transform_vectors(values)\n</code></pre>"},{"location":"meshes/","title":"Meshes","text":"<p>The <code>engeom</code> Python library provides a <code>Mesh</code> class which represents an unstructured triangle mesh in 3D space (simplicial 2-complex).</p> <p>A <code>Mesh</code> consists of a list of vertices and a list of faces. Vertices are a list of 3D points, and faces are a list of unsigned integer triplets that refer to indices in the list of vertices. Each face has the indices of three vertices that form a triangle, listed in counter-clockwise order.</p> <p>Warning</p> <p>The <code>engeom</code> mesh module is still in development and is not yet stable. The API may change in the future.</p>"},{"location":"meshes/#creating-a-mesh","title":"Creating a Mesh","text":"<p>There are currently two direct ways to create a new <code>Mesh</code> object.</p> <ol> <li>From a <code>numpy</code> array of vertices and another <code>numpy</code> array of faces</li> <li>Load from a STL file</li> </ol>"},{"location":"meshes/#from-numpy-arrays","title":"From <code>numpy</code> Arrays","text":"<pre><code>import numpy \nfrom engeom.geom3 import Mesh\n\nvertices = numpy.array([\n    [0, 0, 0],\n    [1, 0, 0],\n    [1, 1, 0],\n    [1, 1, 0],\n    [0, 1, 0],\n    [0, 0, 0],\n], dtype=numpy.float64)\n\ntriangles = numpy.array([\n    [0, 1, 2],\n    [3, 4, 5],\n], dtype=numpy.uint32)\n\nmesh = Mesh(vertices, triangles)\n\nprint(mesh) # &lt;Mesh 6 vertices, 2 faces&gt;\n</code></pre> <p>Tip</p> <p>If you get an error <code>TypeError: argument 'faces': 'ndarray' object cannot be converted to 'PyArray&lt;T, D&gt;'</code>, make  sure to convert the faces array to an unsigned integer type, e.g. <code>numpy.uint32</code>.</p> <p>There are two options which can be used during creation to alter how the vertices and faces are handled.</p> <ul> <li><code>merge_duplicates</code>: If <code>True</code>, duplicate vertices will be merged and duplicate faces will be remoted. Default is   <code>False</code>.</li> <li><code>delete_degenerate</code>: If <code>True</code>, degenerate faces (faces with two or more vertices that are the same) will be removed.    Default is <code>False</code>.</li> </ul> <pre><code>import numpy\nfrom engeom.geom3 import Mesh\n\nvertices = numpy.array([\n    [0, 0, 0],\n    [1, 0, 0],\n    [1, 1, 0],\n    [1, 1, 0],\n    [0, 1, 0],\n    [0, 0, 0],\n], dtype=numpy.float64)\n\ntriangles = numpy.array([\n    [0, 1, 2],\n    [3, 4, 5],\n], dtype=numpy.uint32)\n\nmesh = Mesh(vertices, triangles, merge_duplicates=True)\nprint(mesh) # &lt;Mesh 4 vertices, 2 faces&gt;\n</code></pre>"},{"location":"meshes/#from-stl-file","title":"From STL File","text":"<p>To load a mesh from an STL file, use the static <code>load_stl</code> method.</p> <pre><code>from engeom.geom3 import Mesh\n\nmesh = Mesh.load_stl(\"path/to/file.stl\")\n</code></pre> <p>The <code>load_stl</code> method also has the <code>merge_duplicates</code> and <code>delete_degenerate</code> options.</p>"},{"location":"meshes/#access-vertices-and-faces","title":"Access Vertices and Faces","text":"<p>The vertices and faces of a mesh can be accessed using the <code>vertices</code> and <code>faces</code> properties.</p> <pre><code>from engeom.geom3 import Mesh\n\nmesh = Mesh.load_stl(\"path/to/file.stl\")\n\nprint(mesh.vertices) # Numpy ndarray of shape (N, 3), numpy.float64 data type\nprint(mesh.faces) # Numpy ndarray of shape (M, 3), numpy.uint32 data type\n</code></pre>"},{"location":"meshes/#bounding-volumes","title":"Bounding Volumes","text":"<p>Meshes have a bounding volume which can be accessed using the <code>aabb</code> property, yielding an <code>Aabb3</code> object.</p> <pre><code>from engeom.geom3 import Mesh\n\nmesh = Mesh.load_stl(\"path/to/file.stl\")\nprint(mesh.aabb)\n</code></pre>"},{"location":"meshes/#append-clone-and-transform","title":"Append, Clone, and Transform","text":"<p>The <code>Mesh</code> class supports appending the faces and vertices of another mesh.  After the operation, the mesh which calls the <code>append</code> method will have the vertices and faces of the other mesh appended to it, while the other mesh remains unchanged.</p> <p>If the <code>remove_duplicates</code> flag and/or <code>delete_degenerate</code> flag is set to <code>True</code>, the vertices and faces of the mesh  will be cleaned up after the append operation.</p> <pre><code>from engeom.geom3 import Mesh\n\nmesh1 = Mesh.load_stl(\"path/to/file1.stl\")\nmesh2 = Mesh.load_stl(\"path/to/file2.stl\")\n\nmesh1.append(mesh2)\n</code></pre> <p>The <code>cloned</code> method creates a deep copy of the mesh.</p> <pre><code>from engeom.geom3 import Mesh\n\nmesh = Mesh.load_stl(\"path/to/file.stl\")\n\nmesh2 = mesh.cloned()\n</code></pre> <p>The <code>transform_by</code> method applies a transformation matrix to the vertices of the mesh, leaving the faces unchanged. The object is modified in place.</p> <pre><code>from engeom.geom3 import Mesh, Iso3\n\nt = Iso3.from_translation(1, 0, 0)\nmesh = Mesh.load_stl(\"path/to/file.stl\")\n\nmesh.transform_by(t)\n</code></pre>"},{"location":"meshes/#splitting-and-sectioning","title":"Splitting and Sectioning","text":"<p>There are two operations which can be performed on a mesh using a <code>Plane3</code> object: <code>split</code> and <code>section</code>.</p> <p>The <code>split</code> method takes a <code>Plane3</code> object and returns a tuple of two optional <code>Mesh</code> objects.</p> <ul> <li> <p>The first element in the tuple is the part of the mesh which lies in the negative side of the plane, or <code>None</code> if   there is no such part.</p> </li> <li> <p>The second element in the tuple is the part of the mesh which lies in the positive side of the plane, or <code>None</code> if   there is no such part.</p> </li> </ul> <pre><code>from engeom.geom3 import Mesh, Plane3\n\nmesh = Mesh.load_stl(\"path/to/file.stl\")\nplane = Plane3(1, 0, 0, 1)\n\nmesh1, mesh2 = mesh.split(plane)\n</code></pre> <p>The <code>section</code> method takes a <code>Plane3</code> object and returns a list of <code>Curve3</code> objects which represent the continuous  polylines which are the intersection of the mesh with the plane.</p> <pre><code>from engeom.geom3 import Mesh, Plane3\n\nmesh = Mesh.load_stl(\"path/to/file.stl\")\nplane = Plane3(1, 0, 0, 1)\n\ncurves = mesh.section(plane)\n\nfor curve in curves:\n    print(curve)\n</code></pre>"},{"location":"meshes/#splitting-patches","title":"Splitting Patches","text":"<p>The <code>split_patches</code> method splits the mesh into connected components. The method returns a list of <code>Mesh</code> objects, each representing a connected component of the mesh.</p> <pre><code>from engeom.geom3 import Mesh\n\nmesh = Mesh.load_stl(\"path/to/file.stl\")\n\npatches = mesh.separate_patches()\n</code></pre>"},{"location":"meshes/#sampling","title":"Sampling","text":"<p>The <code>sample_poisson</code> method samples the mesh using a Poisson disk sampling algorithm. The method takes a <code>float</code> parameter which represents the minimum distance between points.</p> <pre><code>from engeom.geom3 import Mesh\n\nmesh = Mesh.load_stl(\"path/to/file.stl\")\nresult = mesh.sample_poisson(0.1)\n</code></pre> <p>In the above example, <code>result</code> will be a <code>numpy</code> array of shape <code>(N, 6)</code> where <code>N</code> is the number of points that resulted from the sampling operation, and each row corresponds with an individual point. The first three columns of the  resulting array are the \\(x\\), \\(y\\), and \\(z\\) coordinates of the point, and the last three columns are the components of the  normal direction of the surface at that point (\\(nx\\), \\(ny\\), \\(nz\\)).</p> <p>The sampling will be done on the surfaces represented by the faces of the mesh, and the points will be distributed approximately evenly over the surface. The points will coincide with the vertices of the mesh, but will instead be random points which lie on the actual triangles.</p>"},{"location":"meshes/#measurements","title":"Measurements","text":"<p>There are a number of measurements which can be made on a mesh.</p>"},{"location":"meshes/#closest-point-on-surface","title":"Closest Point on Surface","text":"<p>The closest point on the surface of a <code>Mesh</code> to an arbitrary point can be found using the <code>surface_closest_to</code> method. This will yield a <code>SurfacePoint3</code> object whose position is the closest point on the mesh, and whose normal is the  normal of the face on which the point lies.</p> <pre><code>from engeom.geom3 import Mesh, Point3\n\nmesh = Mesh.load_stl(\"path/to/file.stl\")\n\nclosest = mesh.surface_closest_to(1, 2, 3)\n\n# Don't forget about the unpacking operator if you are working \n# with points or other iterables\np = Point3(1, 2, 3)\ncl = mesh.surface_closest_to(*p)\n</code></pre>"},{"location":"meshes/#surface-deviation-at-a-single-point","title":"Surface Deviation at a Single Point","text":"<p>Deviation from a surface is a common concept in metrology.  A test point is projected onto the closest face of a mesh, and the \"deviation\" is measured as the distance between the test point and its projection.  The distance is signed so that it is positive if the point lies in the direction of the face normal at the closest point, and negative  otherwise.</p> <p>The <code>measure_point_deviation</code> method calculates the deviation at the location of a single test point. The method returns a <code>Length3</code> object, which is a metrology entity that represents a scalar distance measured between two positions in 3D  along a specified direction.</p> <p>There are two possible modes of computing the distance, specified using the <code>DeviationMode</code> enum.  The two modes are essentially the same except for how they treat points which are beyond the edge of the closest face.</p> <ul> <li> <p><code>DeviationMode.Point</code>: The deviation is calculated as the direct distance from the test point to the closest point on   the face.</p> </li> <li> <p><code>DeviationMode.Plane</code>: The deviation is calculated as the distance from the test point to the plane of the face on   which the closest point lies. This allows for points that are slightly beyond the edge of the closest face to have a   deviation which would be the same as if the edge of the face extended to beyond the test point.</p> </li> </ul> <pre><code>from engeom import DeviationMode\nfrom engeom.geom3 import Mesh\n\nmesh = Mesh.load_stl(\"path/to/file.stl\")\n\nresult = mesh.measure_point_deviation(1, 2, 3, DeviationMode.Point)\n</code></pre>"},{"location":"meshes/#surface-deviation-at-multiple-points","title":"Surface Deviation at Multiple Points","text":"<p>To calculate the deviation of a large number of points at once, use the <code>deviation</code> method, which will return a <code>numpy</code> array with one scalar value of deviation for each test point. Each value will be positive if the test point is in the  direction of the face normal at the closest point, or negative if it is in the opposite direction.</p> <p>Additionally, like the <code>measure_point_deviation</code> method, there are two possible modes of computing the distance. The  method is specified using the <code>DeviationMode</code> enum.  The two modes are essentially the same except for how they treat points which are slightly beyond the edge of the closest face.</p> <ul> <li> <p><code>DeviationMode.Point</code>: The deviation is calculated as the direct distance from the test point to the closest point on   the face.</p> </li> <li> <p><code>DeviationMode.Plane</code>: The deviation is calculated as the distance from the test point to the plane of the face on    which the closest point lies. This allows for points that are slightly beyond the edge of the closest face to have a    deviation which would be the same as if the edge of the face extended to beyond the test point.</p> </li> </ul> <pre><code>import numpy\nfrom engeom import DeviationMode\nfrom engeom.geom3 import Mesh \n\nmesh = Mesh.load_stl(\"path/to/file.stl\")\n\npoints = numpy.array([\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9],\n], dtype=numpy.float64)\n\nvalues = mesh.deviation(points, DeviationMode.Plane)\n</code></pre>"},{"location":"meshes/#face-selection-and-filtering","title":"Face Selection and Filtering","text":"<p>Face selection and filtering allow for the selection/de-selection of faces on the mesh based on certain chained  criteria.  Ultimately, the selection process will produce a list of face indices which can be used for other algorithms, or to extract a new <code>Mesh</code> object constructed from copies of the selected faces.</p> <p>Note</p> <p>This documentation is in progress.</p>"},{"location":"metrology/","title":"Metrology","text":"<p>Warning</p> <p>The metrology feature set is still experimental and is under heavy development in the Rust <code>engeom</code> library. Expect significant changes to the API in the future.</p>"},{"location":"metrology/#introduction","title":"Introduction","text":"<p>The metrology features of the <code>engeom</code> library are designed to provide a common set of tools for actual measurements, separate from the geometry tools. For example, measurements like scalar distances, areas, GD&amp;T form and position  measurements, and more, will be consolidated as entities and operations in the metrology features.</p>"},{"location":"numpy/","title":"Use of Numpy","text":"<p>Numpy is an extension library for the Python programming language which offers support for large, multidimensional arrays and matrices and a number of linear algebra operations that can be performed on them.  It's effectively Python's standard go-to library for linear algebra, and is used heavily by other Python libraries in the scientific computing and data analysis spaces.</p> <p>The underlying <code>engeom</code> Rust library uses <code>nalgebra</code> for dense linear algebra operations and <code>faer</code> for sparse matrix operations. To provide a consistent interface for the Python bindings, the Python <code>engeom</code> library assumes that many users will already be using <code>numpy</code> for bulk operations on arrays of points, vectors, face lists, etc, and so it makes sense to map many of the <code>engeom</code> features which would operate on points/vectors to operate seamlessly on <code>numpy.ndarray</code> objects.</p> <p>To that end, there are a number of conventions used in <code>engeom</code> regarding the use of <code>numpy</code> arrays:</p> <ol> <li> <p>When mapping large arrays of points/vectors, <code>numpy.ndarray</code> objects should be sized as <code>(n, 2)</code> or <code>(n, 3)</code> for 2D and 3D points/vectors, respectively.  Rows represent individual points/vectors, and columns represent the <code>x</code>, <code>y</code>, and <code>z</code>, components of the points/vectors.</p> </li> <li> <p>Some <code>engeom</code> objects will provide access to their data as read-only <code>numpy.ndarray</code> objects. For instance, the <code>Mesh</code> object will expose its vertex and face data as <code>numpy.ndarray</code>s.  The shaping of these arrays will be consistent with the above convention, and floating point data will be 64-bit.</p> </li> <li> <p>Where index-based lists, such as the face vertices lists of the <code>Mesh</code> objects are used, these will typically be expected to be unsigned integer types.  Internally, most are stored as Rust's <code>u32</code> or <code>usize</code> types. If you get an error while constructing objects, such as the <code>Mesh</code>, make sure that the data you are passing in is of the correct type.</p> </li> </ol>"},{"location":"planes_circles_lines/","title":"Planes, Circles, Lines, and Other Geometric Objects","text":""},{"location":"planes_circles_lines/#planes","title":"Planes","text":""},{"location":"planes_circles_lines/#circles-and-arcs","title":"Circles and Arcs","text":""},{"location":"planes_circles_lines/#lines","title":"Lines","text":""},{"location":"points_vectors/","title":"Points and Vectors","text":"<p>Points and vectors are a fundamental geometric primitive within the <code>engeom</code> library that allow for the representation of positions and directions in 2D and 3D space. They are used as components in a number of other geometric entities, but can also be used directly.</p> <p>Note</p> <p>When working with large numbers of points or vectors in Python, it is much more efficient to use <code>numpy</code> arrays than it is to use Python lists of <code>Point2</code>/<code>Point3</code> or <code>Vector2</code>/<code>Vector3</code> objects. The <code>engeom</code> library provides a number of functions which can operate directly on <code>numpy.ndarray</code>s for clarity and speed.</p> <p>The 2D point and vector types are located in the <code>geom2</code> module, while the 3D point and vector types are located in the <code>geom3</code> module.</p> <pre><code>from engeom.geom2 import Point2, Vector2\nfrom engeom.geom3 import Point3, Vector3\n</code></pre>"},{"location":"points_vectors/#creation","title":"Creation","text":"<p>Points and vectors both are created by specifying <code>x</code>, <code>y</code>, and (in the case of the 3D versions) <code>z</code> components.</p> <pre><code>from engeom.geom3 import Point3, Vector3\n\n# Create a 3D point at (1, 2, 3)\np1 = Point3(1, 2, 3)\n\n# Create a 3D vector with components (4, 5, 6)\nv1 = Vector3(4, 5, 6)\n</code></pre> <p>For convenience, you can use Python's <code>*</code> unpacking operator to pass in a list or tuple of values.</p> <pre><code>import numpy\nfrom engeom.geom3 import Point3, Vector3\n\ncoords = numpy.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\npoints = [Point3(*row) for row in coords]\n\nnamed = {\n    \"v0\": (1, 2, 3),\n    \"v1\": (4, 5, 6),\n    \"v2\": (7, 8, 9)\n}\n\nvec0 = Vector3(*named[\"v0\"])\nvec1 = Vector3(*named[\"v1\"])\nvec2 = Vector3(*named[\"v2\"])\n</code></pre> <p>Lastly, for convenience, a point's coordinates can be extracted in the form of a vector.</p> <pre><code>from engeom.geom3 import Point3\n\np = Point3(1, 2, 3)\n\nv = p.coords\nprint(v)  # Vector3(1, 2, 3)\n</code></pre>"},{"location":"points_vectors/#accessing-components","title":"Accessing Components","text":"<p>The <code>x</code>, <code>y</code>, and <code>z</code> components of a point or vector can be accessed directly.</p> <pre><code>from engeom.geom3 import Point3, Vector3\n\nv0 = Vector3(1, 2, 3)\n\nprint(v0.x)  # 1\nprint(v0.y)  # 2\nprint(v0.z)  # 3\n</code></pre> <p>The components are also iterable, so you can unpack them back into a list, tuple, or into arguments for a function.</p> <pre><code>from engeom.geom3 import Point3\n\n\ndef some_function(a: float, b: float, c: float) -&gt; float:\n    return a + b + c\n\n\np = Point3(1, 2, 3)\n\nx, y, z = p\ncoords = list(p)\nvalue = some_function(*p)\n\nfor component in p:\n    print(component)\n</code></pre>"},{"location":"points_vectors/#scaling-points-and-vectors","title":"Scaling Points and Vectors","text":"<p>Points and vectors can be multiplied and divided by scalars.</p> <pre><code>from engeom.geom3 import Point3, Vector3\n\np0 = Point3(1, 2, 3)\nv0 = Vector3(4, 5, 6)\n\np1 = p0 * 2\np2 = 3.0 * p0\nv1 = v0 / 2\n</code></pre> <p>Both can also be inverted, which is equivalent to multiplying by <code>-1</code>.</p> <pre><code>from engeom.geom3 import Point3, Vector3\n\np0 = Point3(1, 2, 3)\nv0 = Vector3(4, 5, 6)\n\np1 = -p0\nv1 = -v0\n</code></pre>"},{"location":"points_vectors/#adding-and-subtracting-points-and-vectors","title":"Adding and Subtracting Points and Vectors","text":"<p>Points and vectors can be added to and subtracted from each other, however, the resulting type will vary depending on the operation.</p> Left Operand Right Result Point <code>+</code> Vector Point Point <code>-</code> Vector Point Point <code>+</code> Point INVALID Point <code>-</code> Point Vector Vector <code>+</code> Vector Vector Vector <code>-</code> Vector Vector Vector <code>+</code> Point INVALID Vector <code>-</code> Point INVALID <p>To summarize, a point cannot be added to anything, and a point can only be subtracted from another point. A vector can be added to or subtracted from either a point or another vector.</p>"},{"location":"points_vectors/#vector-operations","title":"Vector Operations","text":"<p>The length of a vector can be calculated using the <code>norm()</code> function, and a normalized version of the vector can be created using the <code>normalized()</code> function.</p> <pre><code>from engeom.geom3 import Vector3\n\nv = Vector3(1, 2, 3)\n\nlength = v.norm()\nunit = v.normalized()\n</code></pre> <p>Vectors can be used to perform dot and cross products, and to measure the smallest angle between two vectors.</p> <pre><code>from engeom.geom3 import Vector3\n\nv0 = Vector3(1, 2, 3)\nv1 = Vector3(4, 5, 6)\n\nd = v0.dot(v1)\n\nangle = v0.angle_to(v1)\n\n# The cross product will be a new vector if these are `Vector3` objects, \n# or a scalar if they are `Vector2` objects.\nc = v0.cross(v1)\n</code></pre>"},{"location":"surf_points/","title":"Surface Points","text":""},{"location":"surf_points/#overview","title":"Overview","text":"<p>Surface points are a composite structure that consist of a point in space and a normal direction. Conceptually, they come from metrology as a means of representing a point on the surface of an object along with the normal direction of the surface at that point. However, they are also isomorphic with the concept of a ray or a parameterized line with a direction of unit length, and can be used in that way as well.</p>"},{"location":"surf_points/#common-features","title":"Common Features","text":"<p>This section defines features of the <code>SurfacePoint</code> types that are common to both 2D and 3D versions.</p>"},{"location":"surf_points/#construction","title":"Construction","text":"<p>Both the 2D and 3D versions need to be created by specifying the cartesian coordinates and the components of the direction vector. The constructor will automatically scale the direction vector to unit length, so that does not need to be done by the user.</p> <pre><code>from engeom.geom2 import SurfacePoint2\nfrom engeom.geom3 import SurfacePoint3\n\nsp2 = SurfacePoint2(0, 0, 1, 1)\nsp3 = SurfacePoint3(0, 0, 0, 1, 1, 1)\n</code></pre> <p>For convenience, they can also be built from points and vectors using the unpacking operator and the iterable feature of the <code>Point</code> and <code>Vector</code> types.</p> <pre><code>from engeom.geom2 import SurfacePoint2, Point2, Vector2\n\np = Point2(0, 0)\nv = Vector2(1, 1)\n\nsp = SurfacePoint2(*p, *v)\n</code></pre>"},{"location":"surf_points/#accessing-the-point-and-normal","title":"Accessing the Point and Normal","text":"<p>The <code>SurfacePoint</code> types have properties that allow access to the point and normal components, giving you a standard <code>Point</code> and <code>Vector</code> object.</p> <pre><code>from engeom.geom3 import SurfacePoint3\n\nsp = SurfacePoint3(0, 0, 0, 1, 1, 1)\n\nprint(sp.point)\n# Point3(0, 0, 0)\n\nprint(sp.normal)\n# Vector3(0.5773502691896258, 0.5773502691896258, 0.5773502691896258)\n</code></pre>"},{"location":"surf_points/#projection-distances","title":"Projection Distances","text":"<p>There are two distance measuring functions that can be used with <code>SurfacePoint</code> types. Both return scalar floating point values.</p> <ul> <li> <p>The <code>scalar_projection</code> function takes a point in space and returns the scalar projection of the point onto the   normal vector of the <code>SurfacePoint</code>. This is the distance along the normal vector from the <code>SurfacePoint</code> to its   closest approach with the point.</p> </li> <li> <p>The <code>planar_distance</code> function takes a point in space and returns the distance from the <code>SurfacePoint</code> to the test   point projected into the plane defined by the normal vector of the <code>SurfacePoint</code>. This is also the closest distance   from the test point to the ray defined by the <code>SurfacePoint</code>.</p> </li> </ul> <p></p> <p>The <code>SurfacePoint</code> consists of a point and a unit vector normal. The black point \\(sp\\) is the <code>SurfacePoint</code>, and the black attached arrow is its normal vector. The red point \\(p\\) is another point in the same space. Two simple projection measurements are show, the <code>scalar_projection</code> and the <code>planar_distance</code>.  </p>"},{"location":"surf_points/#projection-points","title":"Projection Points","text":"<p>There are two functions of the <code>SurfacePoint</code> types that return new <code>Point</code> objects. These are the <code>at_distance</code> and the <code>projection</code> functions.</p> <ul> <li> <p>The <code>at_distance</code> function takes a scalar distance and returns a new <code>Point</code> object that is that distance along the   normal vector from the <code>SurfacePoint</code>.  This is the same as <code>sp.point + sp.normal * distance</code>.</p> </li> <li> <p>The <code>projection</code> function takes a point in space and returns the point on the <code>SurfacePoint</code>'s normal vector that is   the closest approach to the test point.  This is the same as <code>sp.at_distance(sp.scalar_projection(p))</code>.</p> </li> </ul>"},{"location":"surf_points/#mutating-operations","title":"Mutating Operations","text":"<p>The <code>SurfacePoint</code> types cannot naively participate in addition or subtraction operations because they are neither completely points nor completely vectors, and the results of addition/subtraction are not well-defined.  </p> <p>However, the following operations are defined:</p>"},{"location":"surf_points/#direction-reverse","title":"Direction Reverse","text":"<p>This is equivalent to multiplying the normal vector by -1.</p> <pre><code>from engeom.geom3 import SurfacePoint3\na = SurfacePoint3(0, 0, 0, 1, 0, 0)\nb = a.reversed()\n\nprint(b)\n# SurfacePoint3(0, 0, 0, -1, 0, 0)\n</code></pre>"},{"location":"surf_points/#multiplicationdivision-by-scalars","title":"Multiplication/Division by Scalars","text":"<p>Multiplying or dividing a <code>SurfacePoint</code> by a scalar will multiply/divide the point's coordinates by the scalar.  The magnitude of the normal vector will remain the same, but the direction will be inverted if the scalar is negative.</p> <p>One common use of this is to change the units of the point while keeping the normal vector the same, for instance, when converting from inches to millimeters, or from millimeters to meters.</p> <pre><code>from engeom.geom3 import SurfacePoint3\na = SurfacePoint3(1, 2, 3, 1, 0, 0)\nb = a * 2\n\nprint(b)\n# SurfacePoint3(2, 4, 6, 1, 0, 0)\n</code></pre>"},{"location":"surf_points/#2d-only-features","title":"2D-Only Features","text":"<p>In two dimensions, all rotations take place in the cartesian XY plane and can be described by a single scalar angle. This means there can be a clear concept of orthogonality and rotations are simple to describe.</p> <p>As a result, there are some additional features that are only available in <code>SurfacePoint2</code> objects.</p>"},{"location":"surf_points/#normal-rotation","title":"Normal Rotation","text":"<p>The normal vector of a <code>SurfacePoint2</code> can be rotated by a scalar angle. This is done using the <code>rot_normal</code> function.</p> <pre><code>from engeom.geom2 import SurfacePoint2\nfrom math import pi\n\na = SurfacePoint2(0, 0, 0, 1)\nb = a.rot_normal(pi / 2)\n\n\nprint(b)\n# SurfacePoint2(0, 0, -1, 0)\n</code></pre>"},{"location":"surf_points/#orthogonal-shift","title":"Orthogonal Shift","text":"<p>This is a convenience feature which shifts the position of the <code>SurfacePoint2</code> by a scalar distance in the direction orthogonal to the normal vector. In keeping with the clockwise winding order convention, this is in the direction of the normal vector rotated by 90 degrees in the clockwise direction.</p> <p>For example, if a surface point has a normal vector pointing in the positive Y direction, then a positive shift will move the point in the positive X direction, and a negative shift will move the point in the negative X direction.</p> <pre><code>from engeom.geom2 import SurfacePoint2\na = SurfacePoint2(0, 0, 0, 1)\nb = a.shift_orthogonal(2)\n\nprint(b)\n# SurfacePoint2(2, 0, 0, 1)\n</code></pre>"},{"location":"svd_basis/","title":"SVD Basis","text":"<p>One of the applications of singular value decomposition (SVD) is to find a set of orthonormal basis vectors for a larger set of vectors. This is closely related to the concept of principal component analysis (PCA) in statistics.</p> <p>If given a set of points in \\(\\mathbb{R}^n\\), the singular value decomposition can be used to find a set of \\(n\\) orthonormal basis vectors describing the primary directions of the data. The first basis vector will be the direction which accounts for the most variance in the data, and the last basis vector will be the direction which accounts for the least variance.</p> <p>These basis vectors have a number of different useful applications, the most obvious of which is to use them to create an isometry that maps the original data to a new coordinate system where the basis vectors are the axes. In the case of a large number of co-planar points in 3-space, for example, this could be used to efficiently find a transformation to map them to the XY plane and back. In two or three dimensions, when coupled with careful resampling, it can be used to best fit lines or planes, or to rotate a set of points or geometry to align them with the cartesian axes.</p>"},{"location":"svd_basis/#finding-the-basis","title":"Finding the Basis","text":"<p>To use the SVD basis in <code>engeom</code>, import either the 2D or 3D version of the class from the appropriate <code>geom</code> module. The class will need to be constructed from a numpy array of shape <code>(n, m)</code> where <code>n</code> is the number of points and <code>m</code> is the dimensionality of the points.</p> <p>In the following example, we'll use 10000 random points. X and Z will be random, but Y will be a linear function of X and Z with some noise added. We'll then demonstrate both the 2D and 3D versions of the SVD basis.</p> <pre><code>import numpy\nfrom engeom.geom2 import SvdBasis2\nfrom engeom.geom3 import SvdBasis3\n\n# Create 10000 random points in 3-space\nxs = numpy.random.rand(10000)\nys = xs + numpy.random.rand(10000) * 0.1\nzs = numpy.random.rand(10000)\npoints = numpy.vstack((xs, ys, zs)).T\n\n# Create the 2D SVD basis\nb2 = SvdBasis2(points[:, :2])\nprint(b2.largest())\n# Will print something like: Vector2(0.704, 0.709)\n\n# Create the 3D SVD basis\nb3 = SvdBasis3(points)\nprint(b3.largest())\n# Will print something like: Vector3(0.704, 0.709, 0.0)\n</code></pre> <p>The <code>SvdBasis</code> constructors also have an optional <code>weights</code> argument. To use it, pass in a numpy array of the same length as the number of points, where each element is a floating point weight associated with the point at the same index. The weights will be used to scale the power of each point in the SVD calculation. If the weights are not specified, it's the same as passing in an array of ones.</p>"},{"location":"svd_basis/#using-the-basis","title":"Using the Basis","text":"<p>Once created, the <code>SvdBasis</code> objects have a number of methods related to the basis result.</p> <ul> <li><code>largest()</code> returns the largest basis vector.</li> <li><code>smallest()</code> returns the smallest basis vector.</li> <li><code>rank(tol)</code> returns the rank of the basis, which is the number of singular values greater than a tolerance <code>tol</code>. See   the function documentation for more details on the meaning.</li> <li><code>basis_variances()</code> returns the variances associated with the basis vectors. The first element is the variance of the   largest basis vector, and so on.</li> <li><code>basis_stdevs()</code> returns the standard deviations associated with the basis vectors. The first element is the standard   deviation of the largest basis vector, and so on.</li> </ul> <p>Finally, the <code>to_iso2()</code> and <code>to_iso3()</code> methods can be used to create an isometry that maps the original data in the world coordinate system to the new coordinate system defined by the basis vectors. This is useful for transforming the data to a new coordinate system where the basis vectors are the axes.</p> <pre><code>import numpy\nfrom engeom.geom3 import SvdBasis3\n\n# Create four points at the corners of a tall rectangle\npoints = numpy.array([[0, 0, 0],\n                      [1, 1, 0],\n                      [1, 1, 5],\n                      [0, 0, 5]]).astype(numpy.float64)\n\nb = SvdBasis3(points)\niso = b.to_iso3()\n\nmoved = iso.transform_points(points)\nprint(moved)\n\n# Will print something like:\n# [[ 2.50000000e+00 -7.07106781e-01  3.10862447e-15]\n#  [ 2.50000000e+00  7.07106781e-01  2.66453526e-15]\n#  [-2.50000000e+00  7.07106781e-01 -3.10862447e-15]\n#  [-2.50000000e+00 -7.07106781e-01 -2.22044605e-15]]\n</code></pre> <p>In the above example, the original points formed the corners of a rectangle 5 units tall in the Z direction, \\(\\sqrt{2}\\) units wide, and rotated 45 degrees around the Z axis. </p> <p>After the basis was found and the points transformed by the isometry, the rectangle is now centered at the origin, the long direction goes from -2.5 to +2.5, and the short direction goes from -0.707 to +0.707. The Z values are all essentially zero.</p> <p>By inverting the isometry, you can move points from the basis coordinate system back to the world coordinate system.</p>"},{"location":"airfoils/intro/","title":"Airfoil Introduction","text":"<p>An airfoil is a body designed to produce asymmetrical forces when moving through a fluid. Airfoils are a common subject of metrology and engineering analysis in the aerospace and aerospace propulsion industries.</p> <p>The <code>engeom</code> library has tools for airfoil analysis centered around the 2D cross-sections of airfoil bodies. This is a function of the aerospace industry's historical use of 2D drawings to specify airfoil dimensional requirements and  performance characteristics.</p> <p>Airfoil analysis is a complicated subject with a lot of specialized tools and terminology based on convention and  historical precedent. There aren't typically one-size-fits-all algorithms and methods because of the extreme variation  in airfoil shapes and requirements. Different institutions and organizations even within the same industry will often  have their own preferred methods, tools, and sometimes even terminology.</p>"}]}